---
title: <center> My first day in RStudio </center>
subtitle: <h3 align="center">Absolute beginner in RStudio and GitHub tutorial for Data Science course for EES students</h3>
author: <h5 align= "center"> Zuzi Koscikova </h5>
date: <center> 6 December 2021 </center>
output:
  prettydoc::html_pretty:
    theme: hpstr
  

---

#### __Tutorial Aims__

###  1. What is R and connecting it to GitHub
###  2. Starting to code
###  3. Plotting 
###  4. Saving plots 
###  5. Uploading to GitHub 

------


In case you are as lost as I was during first 1-2 weeks of the Data Science course, this tutorial is for you! I promise you won't be so lost anymore. 
To be honest, it is not so overwhelming once you know what are you doing.</div>


There are just few things you need to be ready for: 

- RStudio likes to not cooperate with you very often but try to avoid breakdowns, it will work somehow

- There will be a lot things to do during the semester, but you can do it! 

- They will be telling you its a lot of fun and you may not agree (especially when your R decides to not work) but it can be fun too 


------- 

### 1. What is R and connecting it to GitHub


You have probably heard already about some of the programming languages such as JavaScript, Python, C, Java... R is also one of them. Actually, in 2021 it was the 8th most useful programming language with annual salary of  $93,000 [(Northeastern.edu)](https://www.northeastern.edu/graduate/blog/most-popular-programming-languages/). It is used mostly for statistical analysis of large data sets and companies like Facebook. Google, New York Times or BBC, Twitter or Microsoft use it. 


To download R, follow 1st part of this [tutorial](https://ourcodingclub.github.io/tutorials/intro-to-r/). 

Now, let’s have a look how the R looks like: 

After opening RStudio, this is what show up. Click on the new file -> R Script (or press Ctrl + Shift + N)



![](pictures/Obrázok1.png){width=75%, align = "center"}



![](pictures/Obrázok2.png)




Now you have all 4 important windows opened. Let's have a look what each of them include and what are they for. 

![](pictures/Obrázok3.png)




You are going to write all the codes into the Script. The results, error and warning messages will show up in the Console window. Created dataframes, vecotrs or objects will be shown in the Environemnt window. In the right bottom window, 3 parts are most important and will be mostly used: Files, Plots and Help. 
In the Files window you can find any files and folders in your computer. It is useful when you want to check where is your files saved or to find filepath of the file. Also, you caneasily check there if your plots are being saved. In the Plots Section all of the figures you coded in the Script will be shown. You can use arrows at the left top corner of the window for swiping between the plots. Lastly, the Helper. It is the place where you can type any function or part of the code which you need help with and it will show you its description, usage, arguments that can be used within the function, value, and also some examples how to use it at the bottom. 
You also can Google any kind of problem and there are many helpful pages on the Internet where you can find the help. To be honest, coding is mostly googling (personaly I cant remember the codes so Google is my very good friend)



------

During the semester, you will mostly use R connected to GitHub, therefore, lets connect them straight away. 
[GitHub](https://github.com/) is a platform used by coders. We will use it mostly with R. It allows you to have a record of your project safely online. Juts think about something like Icloud or OneDrive for your RStudio work. However, it has some more functions we will be using about which I will talk a bit later. Now lets connect R with GitHub
You need to create an account on [GitHub.com](https://github.com/) and follow the instruction for downloading Git to your computer in this [tutorial]. Please, do 1st and 3rd part of the tutorial and come back here 😊. 



Your Git should be now set and connected to R. __Now you are ready to start the semester easily!__ 

Now, lets say you have your course repository on GitHub, in which you want to work in the RStudio. During the whole course, all Challenges will have the specific repository which you will need to connect to R STudio to be able to upload it to GitHub. One of the final assessment is to have your Course Repository nice and full of the work you did during semester. In the course repository you should do all of the Coding Club tutorials. Same as we will connect now your personal Course Repository with Git, you will connect your Challenges repositories. 

On your GitHub you need to go to your repository. Click on the green Code box and copy web URL address. 

![](pictures/Obrázok4.png)
![](pictures/Obrázok5.png)


This way you will “create version control project” – the project in R which will be connected to GitHub and you will be able to upload your work from there. 

Now go back go back to RStudio. Click on Files -> New Project. Choose Version Control and then Git.

![](pictures/Obrázok6.png)
![](pictures/Obrázok7.png)

![](pictures/Obrázok8.png)


Copy the URL address to Repository URL box and choose the folder where your repository will be saved in the computer. I created one folder where I am saving all of my repositories. 

![](pictures/Obrázok9.png)

Now, you can see new tab in the Environment window called Git. Thats the sign all went great and you are connected! There are some additional tasks you need to do when you are connecting your R Studio to Git for the first time, but yuu can follow the previously mentioned [tutorial]() for this. 

![](pictures/Obrázok10.png)

------

###  2. Starting to code

Here we are! Now we are ready to start coding. 

At the beginning, all of your scripts should include the name of the tutorial you are doing (or assessment) - basicaly what is this script about, your name and contact and date. It is recomended to avoid date formats that can be misunderstood by European/American ones. You can use: 6 December 2021

```{r, message = FALSE }

# Data Science: Tutorial                       # note down information about course/Coding club and tutorial
# My first day in RStudio
# Zuzi Koscikova, zuzkakoscikova@gmail.com     # write down your name and contact
# 6 December 2021                              # date should not be in the format easily switched with European/American one

```

•	# : To write comments (anything which you don’t want to be part of the code, need to start with hashtag  __#__  at the beginning of the line

R is working with the different packages, which include different functions. Before you start working on some code, usually you need to have packages installed and loaded. However, you also can code in base R which means you dont need to have any packages because R itself include some functions. In the Data Science, however, most of the tasks require specific packages so lets look at this. 
__To run the code, press Ctrl + Enter___

```{r, message = FALSE}
# Install packages ----
# Here are the most used R packages you will need in Data Science
# First, install packages 
# install.packages is a function we need to use for installing the required package. 
# in the brackets is name of the package in the quotations ""
#install.packages("tidyverse")  # package for data manipulation includes tidyr, dplyr, ggplot2, readr...
#install.packages("ggthemes")   # extra themes, scales and geoms for "ggplot2"

# Load the packages ----
# Load the packages using "library"
# NOTE: Normally it should work without using "" quotations when loading the packages
# however, if it is not working, try with them (this is working for me)
library(tidyverse)
library(ggthemes)
```

To add section in the script, write 4 dash lines after the comment. These can be seen after clicking on the horizontal lines symbol in the upper right corner of the Script window. More hashtages you will add, more to the right will be title moved. (6 is the max)


![](pictures/Obrázok11.png)

Now we can start with the code. In most of the tutorials from COding Club and during course tutorials, there will be data provided in csv format, which you will need to load. 

For this tutorial, you can find all the useful data in this [repository](). Click on the green code box but now choose download ZIP file. Extract ZIP into the folder you created for this tutorial in your course repository. 

To load the data, you need to tell R full filepath which follows after the working directory you are working in right now. To see your working directory, write getwd(). In the console, filepath for your working directory will be seen. 
For example:

```> getwd()
[1] "C:/Users/HP/Desktop/R coding club/tutorial-Zuzi16"
```
As I have the data file in the "tutorial_Zuzi16" folder, I do not need to more specify the filepath. However, when you are doing this tutorial in your course repository folder, you will probably need to specify the rest of the path (depending where you extracted the ZIP folder) which is not specified by your working directory. 
For example:
```
data <- read.csv("Tutorials/My first day in R/LPIdata.csv")
```

```{r, message = FALSE}
# Starting with the code ----
# usually there will be some data provided in csv format you will need to use. 
# when doing tutorials of coding club tutorials, from the github repository you can download ZIP folder. 
# Extract ZIP folder to your course repository folder in the computer. 
## Loading the data ---- 
getwd()
data <- read.csv("LPIdata.csv")
```

data - is the name for our dataframe. You can name it as you want (but be careful this time, because you will need to change it also in the following codes provided).
<-   - is the assign symbol
read.csv  - function used for loading the data in csv format
("filepath/name_of_the_data_file") - first you need to write the full filepath with the name of the file at the end. Write it in speechmarks in brackets. 

In this tutorial, we will have a look on the Living Planet Index (LPI) across the world between years 1970 to 2016. 

After loading the data, it will be shown in the environemnt. 

![](pictures/Obrázok12.png)


Now we can check the data, There are different functions for these. I think the most usefull are summary and glimpse.
Summary will tell you min, max, median, mean, first and third quartile of each column
Glimpse will tell you number of rows, number of columns, and some of the values of each column as well data type such as character, factors, numeric, integer, logical, or complex. Here we have character (chr), integer (int) and dbl stands for double class (numeric values with decimal points). 
We can also open the dataframe by clicking on the data in Environment window.

![](pictures/Obrázok13.png)


```{r, message = FALSE}

## checking the data ----

summary(data)
glimpse(data)
```

We can see the data are very wide, because we have all the years in the rows. It is, however, better and more easy-to-read to have them in the long format. Lets transform it: 

First we need to open our data frame - by clicking on it in the Environment window and check which columns we need to move. Go with the cursor on the first year column and information will show up.

![](pictures/Obrázok14.png)

The first column we need is column 3, the last is 49. 

```{r, message = FALSE}
## Long format ----
# We will transform the wide dataframe into long format by moving all the year columns into one, where they will be bellow each other. 
# We need to check in the dataframe which columns are they in now 

data_long <- pivot_longer(data, cols=3:49, names_to = "year", values_to = "LPI")

# data_long: name of new dataframe
# pivot_longer: operator we are using for transformation of the data
# in the bracket: (data: original data, 
#                  cols=: original columns which needed to be transformed, 
#                  names_to=: name of the new column where all the names from original columns (so all #                             the years) will be moved, 
#                  values_to=: name of the new column where all the values from original columns (so 
#                              all the LPI values) will be moved)

```

if you check the data now, they are in 4 columns. However, we have all years with X at the beginning. This can be easily solved by mutate and parse_number operators. 

```{r, message = FALSE}

# Deleting the X in front of the year values
data_long <- mutate(data_long, year = parse_number(year))

# data_long: name of the new dataframe
# mutate: operator by which we will create column "year"  
# in the brackets: (data, column = )
#        - data_long - We have the same, because we do not need to create another data, frame, we want #                      only change our "data_long" one. 
#       - year = name of (new) column 
#       - parse_number: operator that will extract only numerical values from the (original) column    #                       (year)

```

There are different ways how to code. It is preffered to have the script as clear as possible with the minimal repetitions. That's why we will use pipes __%>%__ (you can also press Ctrl + Shift + M) which can simplify our code by writing more steps into one code: 
Let's join 2 previous codes into one: 


```{r, message = FALSE}
# Using pipes

data_long <- data %>% 
  pivot_longer(cols = 3:49,            # long format
               names_to = "year",
               values_to = "LPI") %>% 
  mutate (year = parse_number(year))   # deleting X in front of the years 

str(data_long$LPI)     # checking the specific column value type
str(data_long$year)
```

First we will write new data frame (or object) we want to create. By the arrow we will assign the original data, whcih should be changed. As we have already said to R, which data we are using, we no longer need to write it again within operator. 

Sometimes you have in your data values, and columns that you don't need. In our data, Entity includes also values for reptiles or whole World. We also have column Code which we do not need. let's delete them

```{r, message = FALSE}
# First, check what different values we have in specific columns
unique(data_long$Entity)
unique(data_long$year)

# Deleting unnecessary data using pipes

data_long <- data_long %>% 
  filter(Entity != "Reptiles") %>% 
  filter(Entity != "World") %>%         # deleting unnecessary data from Entitiy column
  select(-c("Code"))                    # deleting useless column Code
  
  
# We also can connect all of the previous changes into one pipe
data_long <- data %>% 
  pivot_longer(cols = 3:49,               # changing to long format
               names_to = "year",
               values_to = "LPI") %>% 
  mutate (year = parse_number(year)) %>%  # deleting X in front of the years
  filter(Entity != "Reptiles") %>%        # deleting Reptile data
  filter(Entity != "World") %>%           # deleting World data
  select(-c("Code"))                      # deleting column Code
  
```


------
### 3. Plotting 

Now, our data are ready for some plotting. In this tutorial we will cover 4 types of graphs you can do, using basic R and ggplot2 package. 

#### __A. Histograms__
First, let's have a look on the histograms. Often, histograms are used for checking the distribution of the data we are working with. WIth this code, we will plot the histogram to see how frequent is the distribution of specific LPI (living planet index) across different animals and in the range of 46 years (1970-2016). 

Each of the graphs can be made in base R and also by ggplot2. We will create histogram in both, but as in Data Science are mostly used figures created in ggplot2, we will continue with that. 

```{r}
# Plotting ---- 

## Histogram of the LPI 
# with base R
hist(data_long$LPI)                           # histogram of the LPI column from data_long dataset
hist(data_long$LPI, breaks = 30)              # try change number for breaks, it will change the distribution of bars
abline(v=mean(data_long$LPI), col = "red")    # we can also add line of mean, median or other specific number, you can change colour
abline(h=10, col = "blue")
# with abline we can add horizontal (with h) or vertical (with v) lines on the plot. 
# we can plot median, mean or specific number 

# Beautifying of base R histogram
par(cex.main = 1, cex.lab=0.9, cex.axis = 0.7)      
# size of the title (cex.main) and size of axis labels (cex.lab), size of axis values (cex.axis)
hist(data_long$LPI,                          # histogram of the LPI column from data_long dataset
     main= "LPI distribution (1970-2016)",   # title of plot
     xlab= "LPI",                            # x-axis label
     ylab= "Frequency",                      # y-axis label
     col= "bisque",                          # changing colour
     breaks = 30)                            # specifying bars distribution
abline(v=mean(data_long$LPI), col="red3")    # adding mean line in red colour
```

For colour pallete for base R, check this [link](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). 

Now let's try it with ggplot2 package. This package allows us to make much nicer plots and has many functions. 
```{r}

# with ggplot2
(LPI_hist <- ggplot(data_long, aes(x = LPI)) +     
      geom_histogram())
# creating new plot "LPI_hist" by ggplot function, from the "data_long" data, where we are changing x axis name to LPI
# by geom_histogram we are specifying the type of the plot we want

# Beautifying
(LPI_hist <- ggplot(data_long, aes(x = LPI)) +                
    geom_histogram(binwidth = 5, colour = "dark green", fill = "light blue") +    # Changing the binwidth and colours of the bars.   
    geom_vline(aes(xintercept = mean(LPI)),                                # Adding a line for mean abundance
               colour = "orange", linetype = "dashed", size=1) +           # Changing the look of the line
    theme_minimal() +                                         # Changing the theme to get rid of the grey background
    ylab("Count\n") +                                         # Changing the text of the y and x axis label
    xlab("\nLPI")  +                                          # \n adds a blank line between axis and text
    ggtitle("LPI distribution (1970-2016)") +                 # Adding plot title
    theme(axis.text = element_text(size = 12),                # Changing font size of axis labels and title
          plot.title = element_text(hjust=0.5, size = 12),         # hjust = moves to the right/left
          axis.title.x = element_text(size = 12, face = "plain"),  # face="plain" is the default, you can change it to italic, bold, etc. 
          axis.title.y = element_text(size = 12, face= "plain"),
          panel.grid = element_blank(),                  # Removing the grey grid lines
          plot.margin = unit(c(1,1,1,1), units = "cm"))) 
```

"aes" = aesthetic:  this is where you specify your data source and variables, AND the properties of the graph which depend on those variables. If you want all data points to be the same colour, you would define the colour = argument outside the aes() function. If you want the data points to be coloured by a factor’s levels (e.g. by site or species), you specify the colour = argument inside the aes()

colour and fill in geom_hist: "colour" colours the outside (lines) of the bars, while "fill" colours the the inside of the bars. 



### __B. Barplots__

Another type of the plot you can create in R is barplot. With our data, we will create barplot of average LPI values over the 46 years in different entities. For this we will need to first add new column to our data with calculated LPI average. 

```{r}
# BARPLOT ----
        
# barplot of average LPI according to entities 

# adding a new column to our data - average of LPI 
data_long <- data_long %>%    
  group_by(Entity) %>%            # grouping the data by Entity (does similar thing as having data in wide format)
  mutate(LPIaverage = mean(LPI))  # mutate create new column with the name "LPIaverage" which values will be mean of LPI column

# ggplot2
# creating the barplot called "LPI_aver_barplot" from "data_long" data. In our aesthetic we need to specify x and y axis (the names of the specific column used). 
# "fill" in aes tells R to colour the bars according to different Entities. 
(LPI_aver_barplot <- ggplot(data_long, aes(x = Entity, y = LPIaverage, fill=Entity)) +
    geom_bar(position = position_dodge(), stat = "identity") +   # we need to use stat = "identity" when using "geom_bar" and own y values 
    theme_minimal() +
    ggtitle("Average LPI (1970-2016)") +                   # plot title
    ylab("LPI\n") +                                        # y-axis title
    xlab("Entity")  +                                      # x-axis title
    theme(axis.text.x = element_blank(),                   # deleting names of Entities form x-axis
          axis.text.y = element_text(size = 10),           # changing size of y-axis labels
          axis.title = element_text(size = 12, face = "plain"),   # adjusting axis titles size and format
          plot.title = element_text(size = 12, hjust=0.5),        # adjusting plot title size and position
          panel.grid = element_blank(),                           # deleting grid
          legend.text = element_text(size = 10, face = "italic"), # Setting the font for the legend text
          legend.title = element_blank(),                         # Removing the legend title
          legend.position = "right"))                             # Setting legend position 

```

### __C. BOXPLOT__

Next, we will create boxplot of LPI variation across locations. 
Boxplot shows us median (horizontal line in the box), minimum (end of the lower vertical line), maximum (end of the upper vertical line), 1st and 3rd quartile (lower and upper box edges), and outliers (dots). 

```{r}

# BOXPLOT ----

(LPI_boxplot <- ggplot(data_long, aes(Entity, LPI)) + geom_boxplot())  
# creating plot called "LPI_boxplot" by ggplot from "data_long" data. The aesthetic includes x axis and y axis specification. 
# "geom_boxplot() specifyies type of the plot

# Beautifying
(LPI_boxplot <- ggplot(data_long, aes(Entity, LPI)) +             
    geom_boxplot(aes(fill = Entity)) +                             # adding colour of the boxes by Entity (fill=Entity)
    theme_classic() +                                              # changing theme
    ggtitle(" LPI variation across locations (1970-2016)")  +       # plot title
    ylab("LPI\n") +                                                # y-axis title
    xlab("\nLocation")  +                                          # x-axis title
    theme(axis.text.x = element_blank(),                           # deleting x-axis labels (because we have it in the legend)
          axis.title = element_text(size = 14, face = "plain"),    # adjusting axis titles                    
          panel.grid = element_blank(),                            # Removing the background grid lines  
          plot.title = element_text(size = 12, hjust=0.5),         # adjusting plot title   
          plot.margin = unit(c(1,1,1,1), units = , "cm"),          # adding a margin
          legend.text = element_text(size = 10, face = "italic"),  # setting the font for the legend text
          legend.title = element_blank(),                          # removing the legend title
          legend.position = "right"))                              # setting legend position

```


## __D. Scatterplot__

Last plot we will create today is scatterplot. From our data we will create scatterplot of yearly LPI values for each of the location. 

```{r}
# SCATTERPLOT

# scatterplot of LPI for each location
(LPI_scatter <- ggplot (data_long, aes(x = year, y = LPI, colour = Entity)) + geom_point())
# creating a plot called "LPI_scatter" by ggplot from "data_long" data. We are specifying columns for x and y axis and the colour difference based on location
# geom_point() specifies type of the plot

# Beautifying
(LPI_scatter <- ggplot(data_long, aes (x = year, y = LPI, colour =Entity)) +
    geom_point(size = 1.5) +                                # changing point size
    geom_smooth(method = "lm", se=FALSE) +                  # adding linear model fit (method=lm), deleting standard error ribbons (se=false)
    theme_classic() +                                       # changing theme 
    ggtitle("Yearly LPI in different locations (1970-2016)")  +   # plot title
    ylab("LPI\n") +                                               # y-axis title
    xlab("\nYear")  +                                             # x-axis title
    theme(axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),  # adjusting x-axis labels (size, angle, vjust and hjust - vertical and horizontal position)
          axis.text.y = element_text(size = 10),                                    # adjusting y-axis labels
          axis.title = element_text(size = 12, face = "plain"),                     # adjusting axis titles     
          panel.grid = element_blank(),                             # removing the background grid lines               
          plot.margin = unit(c(1,1,1,1), units = , "cm"),           # adding a 1cm margin around the plot
          plot.title = element_text(size = 12, hjust=0.3),          # adjusting plot title 
          legend.text = element_text(size = 10, face = "italic"),   # setting the font for the legend text
          legend.title = element_blank(),                           # removing the legend title
          legend.position = "right"))                               # setting legend position 

```


###  4. Saving plots 

Almost at the end! Now we need to save our beautiful figures. When using ggplot package, you can use ggsave function right below the code for the plot. If you know the name of your plot, you can also save it wherever you want in your script. 
Like this: 

```{r}
# 4. Saving the plots ----

# with ggplot2
getwd()  # to remember your working directory to be able to specify where the plot should be saved 
# One 
ggsave("histogram.jpg", plot=LPI_hist)
ggsave("barplot.jpg", plot= LPI_aver_barplot, width = 7) 
ggsave("boxplot.jpg", plot = LPI_boxplot, width = 7)
ggsave("scatterplot.jpg", plot = LPI_scatter, width = 7)

```
First, in the brackets we need to specify the filepath where your plot will be saved finished by name of the figure.jpg (if you want to save it in jpg format). 
It can look like this: 
```ggsave("Tutorials/My first day in RStudio/Figures/histogram.jpg", ...)```
Second, you need to tell R which plot you want to save. Remember, each of the plots we created has name at the beginning. 
When your plot is saved in weird dimensions, they can be always changed - try the number that works the best for you. You can also specify height= xx. 


If you want to save plots right after their code, you will need to just specify the filepath and name of the figure created. 
Like this: 
```{r}
# Boxplot 
(LPI_boxplot <- ggplot(data_long, aes(Entity, LPI)) +             
    geom_boxplot(aes(fill = Entity)) +                            
    theme_classic() +                                              
    ggtitle("LPI variation across location (1970-2016)")  +       
    ylab("LPI") +                                                  
    xlab("\nLocation")  +                                            
    theme(axis.text.x = element_blank(),                           
          axis.title = element_text(size = 14, face = "plain"),                      
          panel.grid = element_blank(),                              
          plot.title = element_text(size = 12, hjust=0.5),           
          plot.margin = unit(c(1,1,1,1), units = , "cm"),          
          legend.text = element_text(size = 10, face = "italic"),  
          legend.title = element_blank(),                          
          legend.position = "right")) 
ggsave("boxplot1.jpg", width=7, height= 3.5)     # adding ggsave code with specified dimensions and filepath + name of the figure
```

You can check all of the saved figures in the File window any time. There you can also see if the plot was saved (look for time when they were modified). 

Now your turn. Try to save all of the plots we did by adding ggsave below each of them. You can name them differently, so you will see the difference. Do they need different dimensions specifications? 


###  5. Uploading to GitHub 




Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
